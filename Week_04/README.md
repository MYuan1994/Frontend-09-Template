# 第四周

## 字符串算法

### 字典树（Trie）

1. 简介：哈希树变种，一般于<u>大量字符串的统计及排序</u>中使用，例如：搜索引擎中文本词频统计(提取关键词)、搜索联想。

2. 设计：空间换时间，使用字符串的公共前缀来降低查询时间的开销。=>减少多余的字符串比较。

3. 特征：

   除根节点无字符外，每个节点都包含一个字符；

   从根节点到某一节点，途径的节点的字符串连起来是该字符串的前缀或者字符串本身（当到<u>本身</u>的终结符时）；

   每个节点的子节点互不相同（符合symbol的特性）。

### KMP（本周最难的理解的一个）

1. 问题：判断某一字符串是否包含在另一个长字符串里

2. 旧解法：Brute-Force——依次比较长字符串与短字符串中的字符。时间复杂度与两字符串长度相关，为O(n*m)

   ```javascript
   let BF = (Str1, Str2) => {
       let i = 0,
           j = 0;
       while (i < Str1.length && j < Str2.length) {
           if (Str1[i] === Str2[j]) {
               i++;
               j++;
           } else {
               i = i - j + 1;
               j = 0;
           }
       }
   }
   ```

   两串从第一位比较，遇到不匹配的字符，模式串后移一位继续进行匹配，知道比较时遍历完模式串（匹配成功）或遍历完源串（匹配失败）。
   
3. 实现思路：

   1. BF算法执行时，某些次匹配尝试中会有部分匹配但不足完全匹配的情况，这些部分匹配的信息可告知我们那些已匹配的位置无需移回。

   2. 已匹配的信息来源于模式串的“特征”，即模式串的头部会与后方的内容重复，移动时依据已尝试匹配的部分，截去可能作为头部的部分的长度（匹配值），剩下的是不可能匹配的部分，向后移动该部分的长度即可。

   3. 使用<u>部分匹配表</u>（Partial Match Table）获得匹配值，部分匹配表中字符对应的值是该值前缀和后缀（或者按winter老师的向前查找重复字符的思路，更易实现，回退位数无需继续使用公式计算）的公共元素长度，公共元素长度实际上描述了字符串头部与内部的重合度，利用此”特征“可以定位已尝试匹配的部分中可以作为头部的字符（短串）的位置。

      ```javascript
      let i = 1,
                  j = 0;
              while (i < pattern.length) {
                  if (pattern[i] === pattern[j]) {
                      //记录后一字符串不匹配时的回退位数
                      // table[i + 1] = j + 1;//便于理解的写法
                      i++;
                      j++;
                      table[i] = j;
                  } else {
                      if (j > 0) {
                          j = table[j];
                      } else {
                          i++;
                      }
                  }
      
              }
      ```

      

   4. KMP依旧从头开始匹配，在匹配失败后，依据匹配失败字符在部分匹配表中的值和已匹配长度向后移动即可
      $$
      移动位数 = 已匹配的字符数 - 对应的部分匹配值
      $$

   5. 过程依然终结于模式串或者源串遍历结束。若不止一次匹配，需要获取所有独立匹配的部分，成功匹配后向后移动模式串长度的位数然后重新匹配至源串结束即可。除了不匹配时对i（source串中的位置）的操作，其余代码与BF中相似，对于pattern的循环条件可以放进while内部以记录所有匹配防止跳出。

### WildCard

思路：依据模式串的星号，将模式串拆分为`Str1+*Str2+……+*Strn`的模式（其中Str可能为空）；然后将头部、中间、结束依次匹配。其中头部进行字符串全匹配，除`?`有不匹配字符则视为整体匹配失败；中间部分均为`*Str`模式，利用正则对象或者KMP进行模式串&源串的包含匹配即可，有一段遍历完毕后无法匹配视作失败；最后一段因为`*`长度的不确定性以及需确定结束字符的匹配，最后一段的匹配倒叙进行，至遍历到`*`或者不匹配字符和`?`结束。

## 使用知识点

### symbol

**简介：**ES6新增原始数据类型，表示独一无二的值，可以用于解决ES5中使用字符串做属性名容易造成冲突的问题。

使用Symbol函数生成，写作：

​	`let s = Symbol();`

长相极具欺骗性，s容易被认为是对象，实际上是基本类型，所以symbol前不可使用new，s不可添加属性。

symbol函数接受字符串或者对象的toString()作为参数生成symbol，用以描述symbol，主要是为了与其他symbol互相区分写作：

​	`let s = Symbol('s_1');`

参数作为描述并不作为区分symbol的特性，因此相同参数不代表相同symbol，仅说明两个symbol描述相同。其描述除了可以使用toString或者String(s)之外，由ES2019新增使用实例属性description也可以返回描述，写作

​	`s.description;`

symbol仅仅可以转为字符串或者布尔值

**用法：**作为产生的目的，它具备作为不可重复属性名的功能。（公有属性）

首先声明一个symbol，`let mySymbol=Symbol();`

有3种设定方式：

1. `let obj={};	obj[mySymbol]='XXXXXX';`
2. `let obj={[mySymbol]:'XXXXXX'}`;
3. `let obj={}; 	Object.defineProperty(obj,mySymbol,{value:'XXXXXX'});`

*注：*不可使用.运算符，因为其会使obj设定一个与symbol名称相同的属性mySymbol，其值为'XXXXXX'；

​		'XXXXXX'可替换为function

其他用法：用于定义一组常量，保证这组常量的值互不不相等；

## TaskList

- [x] 字典树应用（搜索建议）
- [ ] 词频统计及关键词提取、关键词云图（单词库的获取暂无思路，spark数据集不知道怎么用到js中）
- [ ] BM算法（实现时发现时间复杂度为mn或n，特殊情况下有用，暂不补充）
- [x] wildcard中KMP替换正则