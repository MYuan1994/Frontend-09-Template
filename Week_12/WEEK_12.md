# 第十二周

## CSS排版

### 盒

排版和渲染的基本单位是`盒`

#### 盒模型

盒模型从内到外依次是

1. content：盒的内容的空间。
2. padding：内边距，盒内容content到边框border的距离，决定盒内content的排版。
3. border：边框。
4. margin：外边距，盒本身距离其他盒或容器的举例，决定盒本身的排版。

box-sizing：

- content-box：盒的尺寸仅有content，外加padding、border、margin共同作用于最终排版
- border-box：盒的尺寸包括content、padding

### 正常流

#### 正常流排版

1. 收集盒（与文字）进行
2. 计算盒（与文字）在行中的排布
3. 计算行之间的排布

IFC（行内级格式化上下文）：行内排布，放置inline-box和一些文字，形成line-box。

BFC（块级格式化上下文）：若干line-box和block-level-box（因高度较高等原因需要但独占一行的元素，单独形成盒）在竖向排布。

#### 行内排布

字符就是一个码点，具体的形状是由字体来决定的，**字形**相关概念：

- orgin表示的就是文字的基线的位置
- 文字宽度为 xMax - xMin，高度为 yMax - yMin
- bearingX决定了默认字间距
- 排版时一个字占用的空间叫advance，为字体的宽度和字间距之和

##### 行模型

五线：

1. line-top：行高大于文字的高度时产生
2. text-top：文字的上缘，多种文字混排时，由最大的文字决定；
3. baseline：基线，以英文为主，用来对齐每个字体的线，然后通过其他字形相关参数的作用，形成文字
4. text-bottom：文字下缘，多种文字混排时，由最大的文字决定；
5. line-bottom：行高大于文字的高度时产生

当行内是文字与空白行内盒（inline-block）混排时，盒的下缘会对齐文字基线；

当盒中有文字时，盒中文字的最后一行会与外部文字进行基线对齐；

还可以对在盒上添加`vertical-align`属性，当设置为top、bottom、middle、text-top、text-bottom时，盒分别对齐行的上缘、行的下缘、中心线、文字的上缘、文字的下缘。（[vertical-align](https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align)）

> Affects the vertical positioning of the inline boxes generated by an inline-level element inside a line box.
>
> Syntax: baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>

#### 行盒与块盒的排布

##### float

float的MDN定义：

> float CSS属性指定一个元素应沿其容器的左侧或右侧放置，允许文本和内联元素环绕它。虽然其仍然保持部分的流动性（与绝对定位相反），但该元素已从网页的正常流动(文档流)中移除。

虽然float元素脱离了文档流，但是行盒的位置依然会根据float元素占据的空间进行调整。float影响的不仅是其原来所在行的位置，在其纵向占据空间内的对应行，位置都需要根据float元素进行位置调整。

##### float堆叠

float元素的浮动以接触到上一层盒的边界或者纵向空间有接触的其他float元素为终止。后者会展示为float堆叠现象。

##### clear

clear的MDN定义：

> clear属性指定一个元素是否必须移动(清除浮动后)到在它之前的浮动元素下面。`clear` 属性适用于浮动和非浮动元素。

语法：

```css
/* Keyword values */
clear: none;
clear: left;
clear: right;
clear: both;
clear: inline-start;
clear: inline-end;

/* Global values */
clear: inherit;
clear: initial;
clear: unset;
```

> 两个浮动元素的垂直外边距将不会折叠。当应用于浮动元素时，它将元素的[外边界](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model)移动到所有相关的浮动元素[外边框边界](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model)的下方。这会影响后面浮动元素的布局，后面的浮动元素的位置无法高于它之前的元素。
>
> 要被清除的相关浮动元素指的是在相同[块级格式化上下文](https://developer.mozilla.org/en-US/docs/CSS/block_formatting_context)中的前置浮动。

clear实际作用于float元素时可以理解为为float元素找一个不会与前后其他float元素发生float堆叠的空间，依此可以进行float元素的换行。

##### 外边距折叠现象

盒的margin，代表盒content周围留有的空白范围，而非与其他盒外边距的距离

此现象只会出现在正常流的BFC中，不存在IFC，Flex，Grid中

##### 设立BFC

发生的情况有： 

1. floats 浮动元素内部
2. absolutely positioned elements 绝对定位的元素内部
3. block container that are not block boxes 不是块级盒子的block container 比如：
   - inline-block
   - table-cells
   - table-captions
   - flex items（css3 new）
   - grid cell（css3 new）
   - ...
4. and block boxes with 'overflow' other than 'visible' 块级盒子设置了overflow属性不为visible

##### BFC合并 

默认能容纳正常流的盒（也就是内部不是只能放特定display的元素的盒），我们都认为它会创建BFC，但是只有一种情况例外，就是块级盒子，它里面盒外面都是BFC并且overflow:visible的时候，就会产生内外的BFC合并

发生BFC合并的条件： block box && overflow:visible

- BFC合并与float
- BFC合并与边距折叠

BFC合并，可视为未创建BFC

## CSS动画

### @keyframes与animation

`@keyframes`用来定义关键帧，`animation`用来使用关键帧。用法写作：

```css
/*定义关键帧*/
@keyframes mykf{
    from{
        /*some css rule*/
    }
    to{
        /*some css rule*/
    }
}
/*定义关键帧另外的写法，0%和100%对应from和to*/
@keyframes mykf2{
    0%{
        /*some css rule*/
    }
    50%{
        /*some css rule*/
    }
    100%{
        /*some css rule*/
    }
}
 /*使用关键帧*/
div{
    animation:mykf2 5s infinite;
}
```

`animation`语法构成：

- animation-name：时间曲线（动画调用的关键帧的名字）

- animation-duration：动画时长

- animation-timing-function：动画时间曲线

  `timing-function`（下同），来自于一个[三次贝塞尔曲线](https://cubic-bezier.com/#.17,.67,.83,.67)。

  默认的几种变化：

  1. ease：缓动曲线
  2. linear：线性，一次曲线（无需设置即为此状态）
  3. ease-in：缓动启动，多用于退出动画
  4. ease-out：缓动停止，多用于进入动画
  5. ease-in-out：先加速后减速
  6. 自定义：`cubic-bezier (x1,y1,x2,y2)`

- animation-delay：动画开始前延迟

- animation-iteration-count：动画播放次数（infinite无停止播放）

- animation-direction：动画方向

`@keyframes`语法：

可使用`from-to`也可使用百分比；

每两个关键帧之间加transition，可使动画每帧间的转变不用延续animation-timing-function的设定，单独指定每帧间的转变函数。

`@transition`语法构成：

- transition-property：需要变换的属性
- transition-duration：变换的时长
- transition-timing-function：时间曲线，使用`cubic-bezier`
- transition-delay：延迟

## CSS绘制

### 颜色

三原色：红绿蓝（日常颜料里的三原色补色红黄蓝）

css中颜色参数的多种写法格式：

1. CMYK：出于印刷业

2. RGB

3. HSL：**W3C选择**

   H：Hue，色相；六色盘中的角度。

   S：Saturation，饱和度，纯度；取值0~100%，100%为纯色。

   L：Lightness，亮度；取值0~100%，表现为从黑到白

4. HSV：又称HSB

   V：value，B，Brightness，名度；取值0~100%，表现为从黑到纯色

### 绘制

<u>***使用原生自带属性尽量只做其定义的事情**</u>

#### 几何图形

- border
- box-shadow
- border-radius

#### 文字

- font
- text-decoration

#### 位图

- background-image

绘制图形的技巧：

- OpenGL-Fragment Shader(像素着色器)
- data uri+svg：把svg变成data uri，在需要图片的地方，使用inline的svg描绘图片

## 课外扩展

### X-Frame-Options

#### 定义

The **`X-Frame-Options`** [HTTP](https://developer.mozilla.org/en-US/docs/Web/HTTP) 响应头是用来给浏览器 指示允许一个页面可否在`frame`、`iframe`、`embed`或`object`中展现的标记。站点可以通过确保网站没有被嵌入到别人的站点里面，从而避免 [clickjacking](https://zh.wikipedia.org/wiki/Clickjacking) 攻击。

#### 取值

`X-Frame-Options` 有三个可能的值：

1. X-Frame-Options: deny：表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。
2. X-Frame-Options: sameorigin：表示该页面可以在相同域名页面的 frame 中展示。
3. X-Frame-Options: allow-from https://xxxx.com：表示该页面可以在指定来源的 frame 中展示。

#### 设置

1. 配置 Apache 在所有页面上发送 X-Frame-Options 响应头，需要把下面这行添加到 'site' 的配置中:

   ```java
   Header always set X-Frame-Options "sameorigin"
   ```

2. 配置 nginx 发送 X-Frame-Options 响应头，把下面这行添加到 'http', 'server' 或者 'location' 的配置中:

   ```java
   add_header X-Frame-Options sameorigin always;
   ```

3. 要配置 Express 可以发送 `X-Frame-Options` header，你可以用借助了 [frameguard](https://helmetjs.github.io/docs/frameguard/) 来设置头部的 [helmet](https://helmetjs.github.io/)。在你的服务器配置里面添加：

   ```javascript
   const helmet = require('helmet');
   const app = express();
   app.use(helmet.frameguard({ action: "sameorigin" }));
   ```

   或者，你也可以直接用 [frameguard](https://helmetjs.github.io/docs/frameguard/)：

   ```javascript
   const frameguard = require('frameguard')
   app.use(frameguard({ action: 'sameorigin' }))
   ```

### 几何图形绘制----可视化方式

#### canvas

步骤：

1. 获取 Canvas 对象，通过  getContext(‘2d’) 得到 2D 上下文；

2. 设置绘图状态，比如填充颜色 fillStyle，平移变换 translate 等等；

3. 调用  beginPath 指令开始绘制图形；

4. 调用绘图指令，比如 rect，表示绘制矩形；

5. 调用 fill 指令，将绘制内容真正输出到画布上。

   示例：

   ```javascript
   const rectSize = [100, 100];
   context.fillStyle = 'red';
   context.beginPath();
   context.rect(0.5 * canvas.width, 0.5 * canvas.height, ...rectSize);
   context.fill();
   ```

#### svg

SVG 属于声明式绘图系统，通过声明一些标签就可以实现绘图：

<svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <circle cx="100" cy="50" r="40" stroke="black"
  stroke-width="2" fill="orange" />
</svg>

#### webGL

步骤：

1. 创建 WebGL 上下文

   ```javascript
   const canvas = document.querySelector('canvas');
   const gl = canvas.getContext('webgl');
   ```

2. 创建 WebGL 程序（WebGL Program）

   ```javascript
   const vertex = `
     attribute vec2 position;
   
     void main() {
       gl_PointSize = 1.0;
       gl_Position = vec4(position, 1.0, 1.0);
     }
   `;
   
   
   const fragment = `
     precision mediump float;
   
     void main()
     {
       gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
     }    
   `;
   ```

3. 将数据存入缓冲区

   ```javascript
   const points = new Float32Array([
     -1, -1,
     0, 1,
     1, -1,
   ]);
   
   const bufferId = gl.createBuffer();
   gl.bindBuffer(gl.ARRAY_BUFFER, bufferId);
   gl.bufferData(gl.ARRAY_BUFFER, points, gl.STATIC_DRAW);
   ```

4. 将缓冲区数据读取到 GPU

   ```javascript
   const vPosition = gl.getAttribLocation(program, 'position');//获取顶点着色器中的position变量的地址
   gl.vertexAttribPointer(vPosition, 2, gl.FLOAT, false, 0, 0);//给变量设置长度和类型
   gl.enableVertexAttribArray(vPosition);//激活这个变量
   ```

5. GPU 执行 WebGL 程序，输出结果

   ```javascript
   gl.clear(gl.COLOR_BUFFER_BIT);
   gl.drawArrays(gl.TRIANGLES, 0, points.length / 2);
   ```

## TODO LIST

- [x] 模拟上周爬虫爬取MDN中css属性------getProps.js和输出文件zmy.txt
- [x] 解决X-Frame-Options设置导致的爬虫中iframe（用的window.open()，有点扯）
- [ ] 使用koa搭建node，将爬取内容写入文件和网页
